Why java is platform-independent (supposed)
--------------------------------
Platform consists of the computer hardware (mainly the cpu) and OS.  
Platform = hardware + OS

this is exactly what the saying "all computer problems can be solved by one more level of abstraction" shows.

Platform-dependent languages like c ultimately is converted to the exact machine codes for a particular OS.  
(question: with the same cpu but different os, the machine codes need to be different right?  
The answer must be yes.  
The reason is probably not because the same cpu needs different machine codes, it is because  
any program needs to interact with the OS. thus the same action requires different system function calls in different os;  
and thus the final machine codes will be different.)

On the other hand, java is compiled not for any physical cpu (os?), but for a virtual machine (called Java Virtual Machine, or JVM).  
This means that the JVM is exactly the extra level that handles the platform compatibilities.  
JVM will be different for different OS, but provides the same interface for java codes to run  
(i.e. in java codes' perspective, the virtual machine offers the same instruction set)


Inheritance
--------------------

One class in java can inherit at most from one another class (unlike C++); 
the keyword is 'extends'.

When a class is an inheritance of another, in the constructor it should also call the constructor of its parent class: 
super(arguments);  
here 'super' is like 'this'. 
'this' refers to the class itself, while 'super' refers to its parent.

When the child class needs to use parent's class, it can use: super.methodName(args);


Interface
--------------------------

Reference: http://stackoverflow.com/questions/10839131/implements-vs-extends-when-to-use-whats-the-difference

in java, an interface is something like an class but has not 'implementation' of its declared methods (and other stuff like constant fields, annotations..).  
Only the class that 'implements' the interface can implement the methods.  
This is like the abstract class in C++.

A class can implement multiple interfaces, while cannot inherit from multiple parent classes.


Gui
----------------

Java uses the swing package for gui.

The way of creating a gui is that:  
1. create a container like Jframe  
2. declare a layout for Jframe (this is the master layout); layout itself is a class that defines how the components added will be arranged.  
3. create a subcontainer like JPanel (this is because we want to divide the Jframe to different regions that hold different things in their own layouts) 
	(however, this step can be optional if there are only a few components)  
4. declare a layout for each subcontainer  
5. create components for each subcontainer and add them to the subcontainers  
6. then add the subcontainers to the main container  


If we need to respond to user inputs to some components:  
1. create an event-handler class (or in the same class) that extends all the actionListener interfaces, like keyboardListener, buttonListeners (not exactly these names),
	then create methods for each interfaces; 
	if there are two buttons in the gui, the method to handle button pressed have to find out which one is pressed thru some predefined methods.  
	this can be a bit messy in the codes; it is not per component based.  
	also, the new class needs to keep a reference to the gui object, which can be passed in to the constructor and the gui class creates a event-handler object. 
	this gui is needed whenever the event-handler class need to change anything on the gui.  
2. the gui class has to create a variable of this event-handler class. pass itself ('this') as the argument to the constructor of the event-handler class.    
3. the components that are waiting for user inputs have to call a particular method to listen to actions, with the event-handler object as the argument.  
	if the gui class itself handles the actions, then just pass itself ('this') to the method.


Java in Android
----------------

There must be a java virtual machine there too, which adds one extra level in the os.


Some notes
-------------------

Java filename has to be the same as the class name.

Every public class that you write must be in a separate .java file where the first part of the file name is identical to the class name.

A JAR file is a single file that contains many .class files

To run a jar file, before generating it, we need a Manifest.mf file to indicate what will be the main class in the jar file.  
Manifest.mf looks something like this:

```
Manifest-version: 1.0
Main-Class: HelloWorld
```

To create the jar file: jar cfm helloWorld.jar manifest.mf HellowWorld.class  
where HellowWorld.class is generated by java HelloWorld.java.  
To execute the jar file: java -jar HelloWorld.jar

Why main function has to be in a class: http://stackoverflow.com/questions/2155381/why-the-main-program-in-java-is-put-into-a-class/2155578#2155578
